mat â† > {ğ•Š'.':0;ğ•Š'#':1;ğ•Š'^':2}Â¨Â¨â€¢FLinesâŠ‘â€¢args

# rotate so the guard faces east for convenience
mat â‰âˆ˜âŒ½â†©  # cw
pos â† (â¥Šâ†•â‰¢mat)âŠ‘ËœâŠ‘2âŠËœâ¥Šmat  # extract guard position
map â† mat=1  # remove guard
visits â† 0Â¨ map
visits 1âŒ¾(posâŠ¸âŠ‘)â†©

System â‡ {ğ•Šğ•©:
  mapâ€¿visitsâ€¿posâ€¿history â‡ ğ•©
  done â‡ 0

  InCycle â‡ {ğ•Šğ•©:
    # every fourth history elt faces in the same direction,
    # and is represented in the same coordinate system.
    # were we at this position a multiple of 4 steps ago?
    colâ†âŠ‘<Ë˜â‰âŒŠâ€¿4â¥Šhistory
    {0=â‰ col? 0; âŠ‘((<âŠ‘)âˆŠ1âŠ¸â†“)col}
  }
  AtEdge â‡ {ğ•Šğ•©: Â¬âˆ§Â´ (0<âŠ¢âˆ§âŠ¢<(Â¯1+â‰¢map)Ë™) pos }

  SpacesAhead â‡ {ğ•Šğ•©: # scan ahead to obstacle (guard always faces east)
    lookahead â† {ğ•©â†“ğ•¨âŠmap}Â´ pos
    k â† âŠ‘ (â‰ âŒŠâŠâŸœ1) lookahead  # number of steps that can be walked
    posâŠ¸+Â¨ 0âŠ¸â‹ˆÂ¨â†•k  # positions from self up to obstacle
  }
  Step â‡ {ğ•Šğ•©:
    done â†© (InCycle âˆ¨ AtEdge) @
    done? @;

    sa â† SpacesAhead@
    visits 1Â¨âŒ¾(saâŠ¸âŠ‘)â†© â‹„ pos â†© Â¯1âŠ‘sa â‹„ history âˆ¾Ëœâ†© (<pos) # prepend
    # rotate map and pos ccw so that guard rotates cw relative to it
    mapâ€¿visits âŒ½âˆ˜â‰Â¨â†© â‹„ pos {iâ€¿j:âŸ¨(â‰ map)-(j+1),iâŸ©}â†©
  }
  StepToEnd â‡ {ğ•Šğ•©:
    Step â€¢_while_ {ğ•Šğ•©:Â¬done} @
  }

  ConsiderObstacles â‡ {ğ•Šğ•©:
    sa â† SpacesAhead@
    # consider an obstacle at each yet unvisited(aka unconsidered) space ahead,
    # simulate to see if it leads to a cycle
    LeadsToCycle â† {ğ•©:
      sys â† System âŸ¨1âŒ¾(ğ•©âŠ¸âŠ‘)map,visits,pos,historyâŸ©
      sys.StepToEnd@ â‹„ sys.InCycle@
    }
    +Â´ LeadsToCycleÂ¨ (Â¬visits) (âŠ‘Ëœ/âŠ¢) sa
  }
  CountPotentialCycles â‡ {ğ•Šğ•©:
    {ğ•Šğ•©: ğ•©+â†©ConsiderObstacles@ â‹„ Step@ â‹„ ğ•©} â€¢_while_ {ğ•Šğ•©:Â¬done} 0
  }
}

sys â† System mapâ€¿visitsâ€¿posâ€¿âŸ¨âŸ©
sys.StepToEnd@
â€¢Show +Â´â¥Š sys.visits

sys2 â† System mapâ€¿visitsâ€¿posâ€¿âŸ¨âŸ©
â€¢Show sys2.CountPotentialCycles@

