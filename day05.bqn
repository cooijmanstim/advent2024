ParseNat â† 10âŠ¸Ã—âŠ¸+ËœÂ´ âˆ˜âŒ½ -âŸœ'0'
IsDigit â† '0'âŠ¸â‰¤âˆ§â‰¤âŸœ'9'
IdentifyRegions â† {Â¯1+ğ•©Ã—+`0âŒˆğ•©-Â»ğ•©}
_CollectRuns â† {IdentifyRegionsâˆ˜ğ”½âŠ¸âŠ”}
CollectNumbers â† {ğ•Šs: ParseNatÂ¨ IsDigit _CollectRuns s}

lines â† CollectNumbersÂ¨ â€¢FLinesâŠ‘â€¢args
rulesâ€¿batches â† (((<âŸ¨âŸ©)âŠËœâŠ¢) (â†‘â‹ˆ1âŠ¸+âŠ¸â†“) âŠ¢) lines
n â† 1+ âŒˆÂ´ âˆ¾ lines
mat â† (nâ€¿nâ¥Š0) {aâ€¿bğ•Šmat: 1âŒ¾(aâ€¿bâŠ¸âŠ‘) mat}Â´ rules

IsOrdered â† {ğ•Šxs:
  #!xsâ‰¡â·xs  # no duplicates
  rsâ† (âŠ‘âŸœmat)âŠ¸/ â¥Šâ‹ˆâŒœËœxs  # relevant rules
  âˆ§Â´ ((âˆ§Â´â¥Š) <â—‹ (xsâŠ¸âŠ)âŸœ<)Â´Â¨ rs  # for each rule A|B, A occurs before B
}
correct â† IsOrderedÂ¨ batches

MidElt â† (âŒŠâˆ˜Ã·âŸœ2âˆ˜â‰ )âŠ‘âŠ¢
â€¢Show +Â´ MidEltÂ¨ correct/batches

Order â† {ğ•Šxs:
  #!xsâ‰¡â·xs  # no duplicates
  mâ†xsâŠxsâŠ¸âŠË˜mat  # relevant rows/columns of the adjacency matrix
  m â†© Â¯âˆâ‹†Â¬m  # replace zeros with neg infs; note Â¯âˆâ‹†0=1, Â¯âˆâ‹†1=Â¯âˆ
  m 0Â¨âŒ¾(0â€¿0âŠ¸â‰)â†©  # zeros on the diagonal
  MP â† ((âŒˆÂ´âˆ˜+)âŒœâ—‹(<Ë˜))âŸœâ‰  # max-plus matrix-matrix product
  cm â† MPËœâŸ(âŒˆ2â‹†â¼â‰ xs) m  # "square" log_2 n times
  xs âŠËœ â‹ âŒˆÂ´Ë˜â‰cm  # sort according to longest incoming edge
}
â€¢Show +Â´ MidEltÂ¨ OrderÂ¨ correctÂ¬âŠ¸/batches

