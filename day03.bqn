ParseNat â† 10âŠ¸Ã—âŠ¸+ËœÂ´ âˆ˜âŒ½ -âŸœ'0'
IsDigit â† '0'âŠ¸â‰¤âˆ§â‰¤âŸœ'9'
FirstOccurrence â† {wğ•Šx:
  oâ†wâ·x , iâ†âŠ‘1âŠËœo
  {i=â‰ o ? Â¯1; i}
}
AppearsAt â† {xğ•Šxsâ€¿i: {iâ‰¥â‰ xs ? 0 ; x=iâŠ‘xs}}
ConsumeDigits â† {ğ•Šs:
  i â† +âŸœ1 â€¢_while_ {ğ•©â‰¥â‰ s ? 0 ; IsDigit ğ•©âŠ‘s} 0
  iâ€¿(iâ†‘s)
}

ConsumeMul â† {ğ•Šs:
  done_signalâ†Â¯1â€¿@
  iâ† "mul(" FirstOccurrence s
  {i=Â¯1 ? done_signal;  # reached end, no further mul()s
   i+â†©4
   skip_signalâ†iâ€¿@
   kâ€¿a â† ConsumeDigits iâ†“s
   {k=0 ? skip_signal;  # not followed by any digits
    Â¬ ',' AppearsAt sâ€¿(i+k) ? skip_signal;  # not followed by comma
    lâ€¿b â† ConsumeDigits (i+k+1)â†“s
    {l=0 ? skip_signal;  # not followed by any digits
     Â¬ ')' AppearsAt sâ€¿(i+k+1+l) ? skip_signal;  # not followed by closing parenthesis
     âŸ¨i+k+1+l, ParseNatÂ¨ aâ€¿bâŸ©
  }}}
}

ss â† â€¢FChars âŠ‘â€¢args
CollectMuls â† {mulsğ•Šs:
  {0=â‰ s? muls;
   posâ€¿ab â† ConsumeMul s
   #! sâ‰¢posâ†“s
   {pos=Â¯1 ? muls;
    {abâ‰¡@? muls; mulsâˆ¾(<ab)} CollectMuls posâ†“s
  }}
}
â€¢Show +Â´ Ã—Â´Â¨ âŸ¨âŸ© CollectMuls ss

CollectDoRegions â† {regionsğ•Šs:
  {0=â‰ s? regions;
   iâ† "don't()" FirstOccurrence s
   {i=Â¯1 ? regionsâˆ¾<s;  # reached end; take all of s
    # found don't(); look to recurse after the next do()
    regionsâˆ¾â†©<iâ†‘s
    kâ†"do()" FirstOccurrence iâ†“s
    {k=Â¯1 ? regions;  # reached end
     regions CollectDoRegions (i+k+4)â†“s
  }}}
}
â€¢Show +Â´ +Â´Â¨ Ã—Â´Â¨Â¨ (âŸ¨âŸ©âŠ¸CollectMuls)Â¨ âŸ¨âŸ© CollectDoRegions ss

